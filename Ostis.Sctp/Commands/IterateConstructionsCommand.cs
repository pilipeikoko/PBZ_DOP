using Ostis.Sctp.Arguments;
namespace Ostis.Sctp.Commands
{

    /// <summary>
    /// Команда: Итерирование конструкций.
    /// </summary>
    /// <example>
    /// Следующий пример демонстрирует использование класса <see cref="GetArcElementsCommand"/>
    /// <code source="..\Ostis.Tests\CommandsTest.cs" region="IterateConstructions" lang="C#" />
    /// <para><b>Теперь давайте разберемся в итерировании конструкций.</b></para>
    /// <para>На изображении ниже представлен scg код конструкции, которую итерировали в примере кода.</para>
    /// <para>В зеленых кружочках индексы первого оператора, в синих кружочках индексы второго итератора, а в красных индексы ответа команды.</para>
    /// <img src="media/iterate_constructions.png" />
    /// <para>Итак, нам необходимо найти основной идентификатор узла на русском языке. Для этого можно использовать несколько итераторов в цикле клиентского кода, но это будет медленно, так как нужно будет слать много команд на сервер. Проще использовать команду итерирование конструкций.</para>
    ///<para>Нам известны адрес узла, основной идентификатор, которого нужно найти: nrel_system_identifier, адреса узлов nrel_main_idtf и lang_ru  </para>
    ///<para>Таким образом начальный итератор будет типа f_a_a_a_f</para>
    ///<para>Второй итератор будет типа f_a_f. Второй f потому, что в результате первого итерирования на сервере уже будет известены адреса (их будет несколько) ссылок, где хранится строка идентификатора</para>
    ///<para>Но так как мы еще не знаем этот адрес, то делаем его ScAddress.Unknown</para>
    ///<para>Если вы посмотрите на изображение, станет понятно, как делать подстановку: Первый параметр это индекс элемента в первом итераторе, адрес которого будет подставлен на место  пока неизвестного элемента следующиего итератора, второй параметр это индекс того самого пока неизвестного элемента следующего итератора</para>
    ///<para>В результате команды вовращается одна или несколько констукций, элементы (адреса элементов) в котором располагаются по порядку итераторов. В нашем примере получается, что 2 и 7 элемент это один и тот же адрес нашей искомой ссылки</para>
    /// </example>
    /// <remarks>
    /// Итерирование конструкций необходимо для ускорения работы сервера с итераторами и позволяет строить сложные итераторы для поиска конструкций.
    /// </remarks>
    public class IterateConstructionsCommand : Command
    {
        #region Параметры команды

        private readonly IteratorsChain iteratorsChain;

        #endregion
        
        /// <summary>
        /// Инициализирует новую команду.
        /// </summary>
        /// <param name="iteratorsChain">цепочка итераторов</param>
        public IterateConstructionsCommand(IteratorsChain iteratorsChain)
            : base(CommandCode.IterateConstructions)
        {
             Arguments.Add(this.iteratorsChain=iteratorsChain);
        }
    }
}
